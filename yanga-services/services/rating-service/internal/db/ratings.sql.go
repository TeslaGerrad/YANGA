// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ratings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRating = `-- name: CreateRating :one
INSERT INTO ratings (
    trip_id,
    rater_id,
    rated_id,
    rating,
    feedback
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, trip_id, rater_id, rated_id, rating, feedback, created_at
`

type CreateRatingParams struct {
	TripID   pgtype.UUID `json:"trip_id"`
	RaterID  pgtype.UUID `json:"rater_id"`
	RatedID  pgtype.UUID `json:"rated_id"`
	Rating   int32       `json:"rating"`
	Feedback pgtype.Text `json:"feedback"`
}

func (q *Queries) CreateRating(ctx context.Context, arg CreateRatingParams) (Rating, error) {
	row := q.db.QueryRow(ctx, createRating,
		arg.TripID,
		arg.RaterID,
		arg.RatedID,
		arg.Rating,
		arg.Feedback,
	)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.RaterID,
		&i.RatedID,
		&i.Rating,
		&i.Feedback,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRating = `-- name: DeleteRating :exec
DELETE FROM ratings WHERE id = $1
`

func (q *Queries) DeleteRating(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRating, id)
	return err
}

const getAverageRating = `-- name: GetAverageRating :one
SELECT 
    COALESCE(AVG(rating), 0) as average_rating,
    COUNT(*) as total_ratings
FROM ratings
WHERE rated_id = $1
`

type GetAverageRatingRow struct {
	AverageRating interface{} `json:"average_rating"`
	TotalRatings  int64       `json:"total_ratings"`
}

func (q *Queries) GetAverageRating(ctx context.Context, ratedID pgtype.UUID) (GetAverageRatingRow, error) {
	row := q.db.QueryRow(ctx, getAverageRating, ratedID)
	var i GetAverageRatingRow
	err := row.Scan(&i.AverageRating, &i.TotalRatings)
	return i, err
}

const getRating = `-- name: GetRating :one
SELECT id, trip_id, rater_id, rated_id, rating, feedback, created_at FROM ratings
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRating(ctx context.Context, id pgtype.UUID) (Rating, error) {
	row := q.db.QueryRow(ctx, getRating, id)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.RaterID,
		&i.RatedID,
		&i.Rating,
		&i.Feedback,
		&i.CreatedAt,
	)
	return i, err
}

const getRatingByTripAndRater = `-- name: GetRatingByTripAndRater :one
SELECT id, trip_id, rater_id, rated_id, rating, feedback, created_at FROM ratings
WHERE trip_id = $1 AND rater_id = $2
LIMIT 1
`

type GetRatingByTripAndRaterParams struct {
	TripID  pgtype.UUID `json:"trip_id"`
	RaterID pgtype.UUID `json:"rater_id"`
}

func (q *Queries) GetRatingByTripAndRater(ctx context.Context, arg GetRatingByTripAndRaterParams) (Rating, error) {
	row := q.db.QueryRow(ctx, getRatingByTripAndRater, arg.TripID, arg.RaterID)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.RaterID,
		&i.RatedID,
		&i.Rating,
		&i.Feedback,
		&i.CreatedAt,
	)
	return i, err
}

const getUserRatings = `-- name: GetUserRatings :many
SELECT r.id, r.trip_id, r.rater_id, r.rated_id, r.rating, r.feedback, r.created_at, u.full_name as rater_name
FROM ratings r
JOIN users u ON r.rater_id = u.id
WHERE r.rated_id = $1
ORDER BY r.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserRatingsParams struct {
	RatedID pgtype.UUID `json:"rated_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetUserRatingsRow struct {
	ID        pgtype.UUID      `json:"id"`
	TripID    pgtype.UUID      `json:"trip_id"`
	RaterID   pgtype.UUID      `json:"rater_id"`
	RatedID   pgtype.UUID      `json:"rated_id"`
	Rating    int32            `json:"rating"`
	Feedback  pgtype.Text      `json:"feedback"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	RaterName string           `json:"rater_name"`
}

func (q *Queries) GetUserRatings(ctx context.Context, arg GetUserRatingsParams) ([]GetUserRatingsRow, error) {
	rows, err := q.db.Query(ctx, getUserRatings, arg.RatedID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserRatingsRow{}
	for rows.Next() {
		var i GetUserRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.RaterID,
			&i.RatedID,
			&i.Rating,
			&i.Feedback,
			&i.CreatedAt,
			&i.RaterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRating = `-- name: UpdateRating :one
UPDATE ratings
SET rating = $2, feedback = $3
WHERE id = $1
RETURNING id, trip_id, rater_id, rated_id, rating, feedback, created_at
`

type UpdateRatingParams struct {
	ID       pgtype.UUID `json:"id"`
	Rating   int32       `json:"rating"`
	Feedback pgtype.Text `json:"feedback"`
}

func (q *Queries) UpdateRating(ctx context.Context, arg UpdateRatingParams) (Rating, error) {
	row := q.db.QueryRow(ctx, updateRating, arg.ID, arg.Rating, arg.Feedback)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.RaterID,
		&i.RatedID,
		&i.Rating,
		&i.Feedback,
		&i.CreatedAt,
	)
	return i, err
}
