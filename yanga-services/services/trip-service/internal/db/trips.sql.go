// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trips.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignDriverToTrip = `-- name: AssignDriverToTrip :exec
UPDATE trips
SET driver_id = $2, status = 'accepted', updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type AssignDriverToTripParams struct {
	ID       pgtype.UUID `json:"id"`
	DriverID pgtype.UUID `json:"driver_id"`
}

func (q *Queries) AssignDriverToTrip(ctx context.Context, arg AssignDriverToTripParams) error {
	_, err := q.db.Exec(ctx, assignDriverToTrip, arg.ID, arg.DriverID)
	return err
}

const cancelTrip = `-- name: CancelTrip :exec
UPDATE trips
SET 
    status = 'cancelled',
    cancelled_at = CURRENT_TIMESTAMP,
    cancellation_reason = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type CancelTripParams struct {
	ID                 pgtype.UUID `json:"id"`
	CancellationReason pgtype.Text `json:"cancellation_reason"`
}

func (q *Queries) CancelTrip(ctx context.Context, arg CancelTripParams) error {
	_, err := q.db.Exec(ctx, cancelTrip, arg.ID, arg.CancellationReason)
	return err
}

const completeTrip = `-- name: CompleteTrip :exec
UPDATE trips
SET 
    status = 'completed',
    completed_at = CURRENT_TIMESTAMP,
    actual_fare = $2,
    actual_duration = $3,
    payment_status = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type CompleteTripParams struct {
	ID             pgtype.UUID    `json:"id"`
	ActualFare     pgtype.Numeric `json:"actual_fare"`
	ActualDuration pgtype.Int4    `json:"actual_duration"`
	PaymentStatus  pgtype.Text    `json:"payment_status"`
}

func (q *Queries) CompleteTrip(ctx context.Context, arg CompleteTripParams) error {
	_, err := q.db.Exec(ctx, completeTrip,
		arg.ID,
		arg.ActualFare,
		arg.ActualDuration,
		arg.PaymentStatus,
	)
	return err
}

const createTrip = `-- name: CreateTrip :one
INSERT INTO trips (
    user_id,
    pickup_latitude,
    pickup_longitude,
    pickup_address,
    dropoff_latitude,
    dropoff_longitude,
    dropoff_address,
    estimated_fare,
    estimated_duration,
    distance
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, user_id, driver_id, pickup_latitude, pickup_longitude, pickup_address, dropoff_latitude, dropoff_longitude, dropoff_address, estimated_fare, actual_fare, estimated_duration, actual_duration, distance, status, payment_status, payment_method, started_at, completed_at, cancelled_at, cancellation_reason, created_at, updated_at
`

type CreateTripParams struct {
	UserID            pgtype.UUID    `json:"user_id"`
	PickupLatitude    pgtype.Numeric `json:"pickup_latitude"`
	PickupLongitude   pgtype.Numeric `json:"pickup_longitude"`
	PickupAddress     string         `json:"pickup_address"`
	DropoffLatitude   pgtype.Numeric `json:"dropoff_latitude"`
	DropoffLongitude  pgtype.Numeric `json:"dropoff_longitude"`
	DropoffAddress    string         `json:"dropoff_address"`
	EstimatedFare     pgtype.Numeric `json:"estimated_fare"`
	EstimatedDuration pgtype.Int4    `json:"estimated_duration"`
	Distance          pgtype.Numeric `json:"distance"`
}

func (q *Queries) CreateTrip(ctx context.Context, arg CreateTripParams) (Trip, error) {
	row := q.db.QueryRow(ctx, createTrip,
		arg.UserID,
		arg.PickupLatitude,
		arg.PickupLongitude,
		arg.PickupAddress,
		arg.DropoffLatitude,
		arg.DropoffLongitude,
		arg.DropoffAddress,
		arg.EstimatedFare,
		arg.EstimatedDuration,
		arg.Distance,
	)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DriverID,
		&i.PickupLatitude,
		&i.PickupLongitude,
		&i.PickupAddress,
		&i.DropoffLatitude,
		&i.DropoffLongitude,
		&i.DropoffAddress,
		&i.EstimatedFare,
		&i.ActualFare,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Distance,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveTrip = `-- name: GetActiveTrip :one
SELECT id, user_id, driver_id, pickup_latitude, pickup_longitude, pickup_address, dropoff_latitude, dropoff_longitude, dropoff_address, estimated_fare, actual_fare, estimated_duration, actual_duration, distance, status, payment_status, payment_method, started_at, completed_at, cancelled_at, cancellation_reason, created_at, updated_at FROM trips
WHERE user_id = $1 AND status IN ('pending', 'accepted', 'in_progress')
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetActiveTrip(ctx context.Context, userID pgtype.UUID) (Trip, error) {
	row := q.db.QueryRow(ctx, getActiveTrip, userID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DriverID,
		&i.PickupLatitude,
		&i.PickupLongitude,
		&i.PickupAddress,
		&i.DropoffLatitude,
		&i.DropoffLongitude,
		&i.DropoffAddress,
		&i.EstimatedFare,
		&i.ActualFare,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Distance,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDriverActiveTrip = `-- name: GetDriverActiveTrip :one
SELECT id, user_id, driver_id, pickup_latitude, pickup_longitude, pickup_address, dropoff_latitude, dropoff_longitude, dropoff_address, estimated_fare, actual_fare, estimated_duration, actual_duration, distance, status, payment_status, payment_method, started_at, completed_at, cancelled_at, cancellation_reason, created_at, updated_at FROM trips
WHERE driver_id = $1 AND status IN ('accepted', 'in_progress')
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetDriverActiveTrip(ctx context.Context, driverID pgtype.UUID) (Trip, error) {
	row := q.db.QueryRow(ctx, getDriverActiveTrip, driverID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DriverID,
		&i.PickupLatitude,
		&i.PickupLongitude,
		&i.PickupAddress,
		&i.DropoffLatitude,
		&i.DropoffLongitude,
		&i.DropoffAddress,
		&i.EstimatedFare,
		&i.ActualFare,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Distance,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDriverTrips = `-- name: GetDriverTrips :many
SELECT id, user_id, driver_id, pickup_latitude, pickup_longitude, pickup_address, dropoff_latitude, dropoff_longitude, dropoff_address, estimated_fare, actual_fare, estimated_duration, actual_duration, distance, status, payment_status, payment_method, started_at, completed_at, cancelled_at, cancellation_reason, created_at, updated_at FROM trips
WHERE driver_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetDriverTripsParams struct {
	DriverID pgtype.UUID `json:"driver_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) GetDriverTrips(ctx context.Context, arg GetDriverTripsParams) ([]Trip, error) {
	rows, err := q.db.Query(ctx, getDriverTrips, arg.DriverID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Trip{}
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DriverID,
			&i.PickupLatitude,
			&i.PickupLongitude,
			&i.PickupAddress,
			&i.DropoffLatitude,
			&i.DropoffLongitude,
			&i.DropoffAddress,
			&i.EstimatedFare,
			&i.ActualFare,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.Distance,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingTrips = `-- name: GetPendingTrips :many
SELECT t.id, t.user_id, t.driver_id, t.pickup_latitude, t.pickup_longitude, t.pickup_address, t.dropoff_latitude, t.dropoff_longitude, t.dropoff_address, t.estimated_fare, t.actual_fare, t.estimated_duration, t.actual_duration, t.distance, t.status, t.payment_status, t.payment_method, t.started_at, t.completed_at, t.cancelled_at, t.cancellation_reason, t.created_at, t.updated_at, u.full_name, u.phone_number, u.profile_image_url
FROM trips t
JOIN users u ON t.user_id = u.id
WHERE t.status = 'pending'
ORDER BY t.created_at DESC
LIMIT $1 OFFSET $2
`

type GetPendingTripsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPendingTripsRow struct {
	ID                 pgtype.UUID      `json:"id"`
	UserID             pgtype.UUID      `json:"user_id"`
	DriverID           pgtype.UUID      `json:"driver_id"`
	PickupLatitude     pgtype.Numeric   `json:"pickup_latitude"`
	PickupLongitude    pgtype.Numeric   `json:"pickup_longitude"`
	PickupAddress      string           `json:"pickup_address"`
	DropoffLatitude    pgtype.Numeric   `json:"dropoff_latitude"`
	DropoffLongitude   pgtype.Numeric   `json:"dropoff_longitude"`
	DropoffAddress     string           `json:"dropoff_address"`
	EstimatedFare      pgtype.Numeric   `json:"estimated_fare"`
	ActualFare         pgtype.Numeric   `json:"actual_fare"`
	EstimatedDuration  pgtype.Int4      `json:"estimated_duration"`
	ActualDuration     pgtype.Int4      `json:"actual_duration"`
	Distance           pgtype.Numeric   `json:"distance"`
	Status             string           `json:"status"`
	PaymentStatus      pgtype.Text      `json:"payment_status"`
	PaymentMethod      pgtype.Text      `json:"payment_method"`
	StartedAt          pgtype.Timestamp `json:"started_at"`
	CompletedAt        pgtype.Timestamp `json:"completed_at"`
	CancelledAt        pgtype.Timestamp `json:"cancelled_at"`
	CancellationReason pgtype.Text      `json:"cancellation_reason"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
	FullName           string           `json:"full_name"`
	PhoneNumber        string           `json:"phone_number"`
	ProfileImageUrl    pgtype.Text      `json:"profile_image_url"`
}

func (q *Queries) GetPendingTrips(ctx context.Context, arg GetPendingTripsParams) ([]GetPendingTripsRow, error) {
	rows, err := q.db.Query(ctx, getPendingTrips, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingTripsRow{}
	for rows.Next() {
		var i GetPendingTripsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DriverID,
			&i.PickupLatitude,
			&i.PickupLongitude,
			&i.PickupAddress,
			&i.DropoffLatitude,
			&i.DropoffLongitude,
			&i.DropoffAddress,
			&i.EstimatedFare,
			&i.ActualFare,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.Distance,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FullName,
			&i.PhoneNumber,
			&i.ProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrip = `-- name: GetTrip :one
SELECT id, user_id, driver_id, pickup_latitude, pickup_longitude, pickup_address, dropoff_latitude, dropoff_longitude, dropoff_address, estimated_fare, actual_fare, estimated_duration, actual_duration, distance, status, payment_status, payment_method, started_at, completed_at, cancelled_at, cancellation_reason, created_at, updated_at FROM trips
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTrip(ctx context.Context, id pgtype.UUID) (Trip, error) {
	row := q.db.QueryRow(ctx, getTrip, id)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DriverID,
		&i.PickupLatitude,
		&i.PickupLongitude,
		&i.PickupAddress,
		&i.DropoffLatitude,
		&i.DropoffLongitude,
		&i.DropoffAddress,
		&i.EstimatedFare,
		&i.ActualFare,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Distance,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTripWithDetails = `-- name: GetTripWithDetails :one
SELECT 
    t.id, t.user_id, t.driver_id, t.pickup_latitude, t.pickup_longitude, t.pickup_address, t.dropoff_latitude, t.dropoff_longitude, t.dropoff_address, t.estimated_fare, t.actual_fare, t.estimated_duration, t.actual_duration, t.distance, t.status, t.payment_status, t.payment_method, t.started_at, t.completed_at, t.cancelled_at, t.cancellation_reason, t.created_at, t.updated_at,
    u.full_name as user_name,
    u.phone_number as user_phone,
    u.profile_image_url as user_image,
    d.full_name as driver_name,
    d.phone_number as driver_phone,
    d.profile_image_url as driver_image
FROM trips t
JOIN users u ON t.user_id = u.id
LEFT JOIN users d ON t.driver_id = d.id
WHERE t.id = $1
LIMIT 1
`

type GetTripWithDetailsRow struct {
	ID                 pgtype.UUID      `json:"id"`
	UserID             pgtype.UUID      `json:"user_id"`
	DriverID           pgtype.UUID      `json:"driver_id"`
	PickupLatitude     pgtype.Numeric   `json:"pickup_latitude"`
	PickupLongitude    pgtype.Numeric   `json:"pickup_longitude"`
	PickupAddress      string           `json:"pickup_address"`
	DropoffLatitude    pgtype.Numeric   `json:"dropoff_latitude"`
	DropoffLongitude   pgtype.Numeric   `json:"dropoff_longitude"`
	DropoffAddress     string           `json:"dropoff_address"`
	EstimatedFare      pgtype.Numeric   `json:"estimated_fare"`
	ActualFare         pgtype.Numeric   `json:"actual_fare"`
	EstimatedDuration  pgtype.Int4      `json:"estimated_duration"`
	ActualDuration     pgtype.Int4      `json:"actual_duration"`
	Distance           pgtype.Numeric   `json:"distance"`
	Status             string           `json:"status"`
	PaymentStatus      pgtype.Text      `json:"payment_status"`
	PaymentMethod      pgtype.Text      `json:"payment_method"`
	StartedAt          pgtype.Timestamp `json:"started_at"`
	CompletedAt        pgtype.Timestamp `json:"completed_at"`
	CancelledAt        pgtype.Timestamp `json:"cancelled_at"`
	CancellationReason pgtype.Text      `json:"cancellation_reason"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
	UserName           string           `json:"user_name"`
	UserPhone          string           `json:"user_phone"`
	UserImage          pgtype.Text      `json:"user_image"`
	DriverName         pgtype.Text      `json:"driver_name"`
	DriverPhone        pgtype.Text      `json:"driver_phone"`
	DriverImage        pgtype.Text      `json:"driver_image"`
}

func (q *Queries) GetTripWithDetails(ctx context.Context, id pgtype.UUID) (GetTripWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getTripWithDetails, id)
	var i GetTripWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DriverID,
		&i.PickupLatitude,
		&i.PickupLongitude,
		&i.PickupAddress,
		&i.DropoffLatitude,
		&i.DropoffLongitude,
		&i.DropoffAddress,
		&i.EstimatedFare,
		&i.ActualFare,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.Distance,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserName,
		&i.UserPhone,
		&i.UserImage,
		&i.DriverName,
		&i.DriverPhone,
		&i.DriverImage,
	)
	return i, err
}

const getUserTrips = `-- name: GetUserTrips :many
SELECT id, user_id, driver_id, pickup_latitude, pickup_longitude, pickup_address, dropoff_latitude, dropoff_longitude, dropoff_address, estimated_fare, actual_fare, estimated_duration, actual_duration, distance, status, payment_status, payment_method, started_at, completed_at, cancelled_at, cancellation_reason, created_at, updated_at FROM trips
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserTripsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetUserTrips(ctx context.Context, arg GetUserTripsParams) ([]Trip, error) {
	rows, err := q.db.Query(ctx, getUserTrips, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Trip{}
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DriverID,
			&i.PickupLatitude,
			&i.PickupLongitude,
			&i.PickupAddress,
			&i.DropoffLatitude,
			&i.DropoffLongitude,
			&i.DropoffAddress,
			&i.EstimatedFare,
			&i.ActualFare,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.Distance,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startTrip = `-- name: StartTrip :exec
UPDATE trips
SET 
    status = 'in_progress',
    started_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) StartTrip(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, startTrip, id)
	return err
}

const updateTripStatus = `-- name: UpdateTripStatus :exec
UPDATE trips
SET status = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateTripStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateTripStatus(ctx context.Context, arg UpdateTripStatusParams) error {
	_, err := q.db.Exec(ctx, updateTripStatus, arg.ID, arg.Status)
	return err
}
